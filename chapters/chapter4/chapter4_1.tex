\section{Rationale}\label{sec:einleitungkonzept}
Im Folgenden werden grundsätzliche Entscheidungen für die Gestaltung des \ac{EUD}-Kon\-zepts auf Basis der Anforderungen getroffen. Zu diesem Zweck werden diese Entscheidungsalternativen aufgezählt, beschrieben und auf Basis ihrer Vor- und Nachteile ausgewählt und begründet.

\subsection{Optionen}\label{subsec:optionen}
In den vorherigen Kapiteln (Sektion \ref{subsec:stateoftheart} u. Kapitel \ref{chapter:analyse}) wurden die Qualitäten/eigenschaften von bestehenden \ac{EUD}-Lösungen in Form von Darstellung und Programmierparadigma diskutiert, sowie die Probleme und Anforderungen, die an das Projekt gestellt werden, analysiert. Aus der folgenden Arbeit resultieren zwei grundlegende Entscheidungen, die für das Konzept getroffen werden: die \textbf{Darstellungsform} des Programmcodes und das \textbf{Programmierparadigma} selbst. 

Für die Darstellungsform der Programmlogik innerhalb der \ac{EUD} kommen zwei Optionen in Frage:
\paragraph{Textuelle Darstellung} Hierunter zählen viele \textit{general-purpose} Programmiersprachen wie C, Java, etc. und spezifische \acp{DSL}. Instruktionen zur Verarbeitung von Informationen werden hierbei in einem Fließtext gespeichert bzw. dargestellt. Generische Programmiersprachen besitzen einen sehr hohen Abstraktionsgrad, da sie prinzipiell von ihrem Anwendungsdomäne losgelöst sind. \acp{DSL} sind wie der Name suggeriert vom Abstraktionsgrad wesentlich näher an der Anwendungsdomäne. Sie bilden einen Kompromiss zwischen Erlernbarkeit und Umfang der Anwendbarkeit (\cite{green1991comprehensibility}).

\paragraph{Graphische Darstellung} In dieser Darstellungsform werden Programme durch Manipulation von graphischen Elementen und Symbolen erstellt. Durch die Verwendung von graphischen Elementen wird versucht eine Metapher zwischen der physischen Welt und der digitalen Welt zu erstellen. Die Anwendungsbereiche sind vielfältig; sie reichen von Pädagogik (z.B. Scratch) zu domänenspezifische Anwendungen (z.B. SAM Studio) zu \textit{general-purpose} Anwendung (z.B. Node-RED oder DRAKON). 

Aus den vorherigen Kapiteln haben sich zwei Programmierparadigmen im \ac{EUD} für \ac{IoT} als besonders relevant hervorgetan:

\paragraph{Regeln-basiert} Das Paradigma der Regeln-basierte Programmierung manifestiert sich in Form von \ac{TAP}. Hierbei werden eintreffende Signale, mit einem Datensatz von natürlich-sprachliche Regeln, auf ihre Wahrheit geprüft. Erfüllung der Regeln führen zur Erzeugung neuer Signale oder dem Auslösen von Aktionen. 
\paragraph{Datenfluss-basiert} Anders als bei Kontrollfluss-Paradigmen, wird hierbei ein Programm nicht als ein Set von Instruktionen angesehen, die sequentiell auf einen Satz von zentral gespeicherten Daten angewandt werden (\textit{Data at rest}/von Neumann Architektur), sondern die Daten selbst werden durch einen Graphen von statischen Instruktionen geleitet (\textit{Data in motion}). Funktionen, welche die Daten transformieren sind dabei \textit{Black Boxen}, welche sobald an sämtlichen Schnittstellen Daten anliegen, diese verarbeiten. Dieses Verhalten macht Datenfluss-basierte Programmierung, im Vergleich zu Kontrollfluss-Paradigmen inhärent asynchron und parallel (\cite{johnston2004advances}).

\subsection{Beurteilung}
Im Anbetracht der Stakeholder, Anforderungen und Zielsetzung des Projekts werden im Folgenden die Vor- und Nachteile der jeweiligen Optionen aus Kapitel \ref{subsec:optionen} gegeneinander Abgewogen, um einen grundlegenden Konsens für das \ac{EUD}-Konzept fest zu legen.

Textuelle Darstellung ist aus gutem Grund, eine der am weit verbreitetsten Darstellungsformen von Programmcode. Dies hat vielerlei Gründe: zuallererst spricht für eine textuelle Darstellung die Informationsdichte und Deskriptivität von geschriebenen Sprachen. Mit nur wenigen Zeichen, lassen sich komplexe Konstrukte und Verhalten beschreiben. Ausdrücke wie ''\textit{Abstract}'' sind schwer visuell eindeutig darzustellen.  Gleichzeitig bedeutet diese Ausdrucksstärke aber auch, dass dem Benutzer das Erlernen eines großen, abstrakten Vokabulars zumutbar sein muss. Zusätzlich muss hier darauf hingewiesen werden, dass die Ausdrucksstärke von textuellen Programmcode immer von den Fähigkeiten und dem mentalen Modell des Entwicklers abhängig ist. Diese Eigenschaften decken sich nicht mit den Fähigkeiten von Laura.

Über Intuitivität und Flexibilität textueller Darstellung lässt sich nur schwer Pauschalisieren. Die Darstellung von parallelem Programmcode stellt sich allerdings als besondere Herausforderung dar. Solange Programmcode sequentiell ausgeführt wird, ist die kognitive Anstrengung für den Entwickler vergleichsweise gering; von links nach rechts von oben nach unten wird der Programmcode, wie beim manuellen Lesen, ausgeführt. Simultane, mehrschichtige Ausführung von parallelem Programmcode hingegen, entspricht nicht der Metapher des sequentiellen Lesens. Hierbei leisten multidimensionale graphische Darstellungen Hilfestellung für den Benutzer. Graphische Oberflächen haben allerdings noch weitere Vorteile: im Kontext von domänenspezifischer Softwareentwicklung können sie wie \acp{DSL} durch (visuelle) Metaphern leichter, Brücken zum Anwendungskontext, schlagen. Diese domänenspezifischer Darstellung ermöglicht es Domänenexperten, die nur wenig Erfahrung mit Programmierung haben, ihr Wissen trotzdem auf die virtuelle Welt zu übertragen. Diese Theorie wird dadurch gestützt, dass die erfolgreichsten visuellen Programmiersprachen (LabVIEW, vvvvv, etc.) stark in ihrer Darstellung mit der Anwendungsdomäne gekoppelt sind und klar abgesteckten Rahmenbedingungen hinsichtlich Funktionalität besitzen. Auch Kritik gibt es gegenüber visueller Darstellung von Programmcode. Das \textit{Deutsch-Limit} nach [\cite{begel1996logoblocks}] besagt, dass es kaum möglich ist mehr als 50 Elemente gleichzeitig auf einem Bildschirm anzuzeigen, ohne die Übersicht zu verlieren. Bei einer textuellen Darstellung ist dieses Limit aufgrund der großen Informationsdichte wesentlich höher.

Die Diskussion über Datenfluss-basierter und Regeln-basierter Programmierparadigmen wurde schon an anderer Stelle geführt. Stellvertretend für beide Paradigmen können die Vor- und Nachteile von IFTTT und SAM Studio in Kapitel \ref{sec:loesungsans} bzw. die Probleme dieser Ansätze in Kapitel \ref{sec:problemanalyse} nachgelesen werden. Grundsätzlich ist zu sagen, dass der größte Vorteil von Regel-basierten Paradigmen die intuitive Natürlichsprachligkeit der Programmierung. Nachteile beinhalten mangelnde Übersicht bei großen Mengen an Regeln, Diskrepanzen bei der genauen Deutung der Regel durch Endnutzer und mangelnde Ausdrucksfähigkeit von Regeln mit komplexen Sachverhalten. Auf der anderen Seite basieren Datenfluss-Paradigmen ebenso auf einer soliden, für den End-Nutzer visualisierbaren Metapher. Dies zeigt sich in der Nutzung des Paradigmas in vielen Werkzeugen mit denen Endnutzer ohne Erfahrung in Softwareentwicklung produktiv arbeiten müssen: vvvv\footnote{\url{https://vvvv.org/} -- besucht August 2018} (für Designer), LabVIEW\footnote{\url{http://www.ni.com/de-de/shop/labview.html} -- besucht August 2018} (für Mathematiker u. Elektronikingenieure), unreal blueprint\footnote{\url{https://docs.unrealengine.com/en-us/Engine/Blueprints} -- besucht August 2018} (für Spieledesigner), etc.\,. Der Fokus auf Daten und ihre Transformation ist eine Parallele zwischen Datenfluss-Programmierung und der Charakteristiken der \ac{IoT} bzw. \textit{Smart Devices}. Dies ist ein Grund für die Verbreitung des Paradigmas in dieser Domäne. Nachteilig ist die erhöhte Komplexität im Vergleich zu Regeln-basierten Ansätzen und der hiermit verbundene Lernaufwand für den Endnutzer.

\subsection{Entscheidung}
Es ist aus der Diskussion ersichtlich, dass es schwierig eine klare Entscheidung für Programmierparadigma und Darstellung des Programmcodes zu treffen. Es gibt viele weitere Vor- und Nachteile die man noch vortragen könnte, man muss allerdings bedenken, dass die Effektivität einer solchen Entscheidung hinsichtlich Benutzerfreundlichkeit/Erlernbarkeit/etc. sich erst \textit{a posteriori} beurteilen lässt. Dies hat auch damit zu tun, dass jede \ac{EUD} speziell für ein Szenario konzipiert wird und es somit nur wenige vergleichbare Arbeiten bzw. Erprobungen in \ac{IoT}-Bereich der \acp{EUD} gibt. Nichtsdestotrotz, wird sich an dieser Stelle für eine Datenflussparadigma mit graphischer Darstellung als \ac{EUD} für flowws festgelegt. Die Punkte die für die Wahl ausschlaggebend sind:
\begin{itemize}
    \item \textbf{Graphische Darstellung} Es gibt viele Werkzeuge wie vvvv oder Scratch die schon jetzt von Designern und anderen Endnutzern verwendet werden, um in anderen Domänen, visuell zu Programmieren. Die graphische Darstellung hilft durch geeignete Metaphern, die Domäne mit dem Programmcode zu verbinden und unterstützt dabei die visuelle Denkweise von Stakeholdern wie Laura ohne sie mit abstrakten Konstrukten zu belasten. Es wird sich dadurch erhofft, die Erlernbarkeit zu fördern (siehe \hyperref[tab:NFA2]{NFA\#2}).
    \item \textbf{Graphische Darstellung} Zum digitalen Entwickeln von Prototypen in flowws, werden die physischen cBlocks benötigt. Es ist somit naheliegend, dass man die Visualität der Realität auf die virtuellen Repräsentation abbildet. flowws soll durch diese Darstellung der Elemente,  die kognitive Last von Laura reduzieren. Diese Bindung von physischem und virtuellen Zustand soll die Anforderung  \hyperref[tab:NFA1]{NFA\#1} erfüllen.
    \item \textbf{Datenfluss-Paradigma} Das Datenfluss-Paradigma ist schwerer zu erlernen wie das natürlichsprachige Regeln-basierte Paradigma. Allerdings ist die Metapher näher an der Realität. Auf elektrotechnischer Ebene wandeln cBlocks physische Phänomene in digitale Signale um, transformieren sie in eine verwendbare Form und wandeln durch Aktoren diese Signale wiederum in physikalische Phänomene um. Dieser Datenfluss auf Basis von elektrischen Signalen kann effizient durch ein Datenfluss-Paradigma auf Programmcode-Ebene emuliert werden. Es wird sich davon versprochen, die Benutzbarkeit von flowws zu verbessern und die kognitive Dissonanz zwischen Elektro- und Informatikebene zu mindern.
    \item \textbf{Datenfluss-Paradigma} Datenflüsse lassen sich gut visualisieren und  geht deshalb Hand-in-Hand mit der graphischen Darstellung des Programmcodes. Dies kommt der Benutzerfreundlichkeit und Fehleridentifikation zu Gute. Durch das Paradigma und dessen Visualisierung wird sich erhofft, Parallelität leichter begreifbar zu machen (siehe \hyperref[tab:NFA0]{NFA\#0}).
\end{itemize}

Aus diesen Gründen wurde sich für eine \ac{EUD} mit graphischer Programmierung auf Basis des Datenflussparadigmas festgelegt.
