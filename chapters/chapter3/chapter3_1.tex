\section{Problemanalyse}\label{sec:problemanalyse}
Im vorherigen Kapitel wurde der Kontext der \ac{EUD}-Umgebung analysiert. Im Folgenden werden daraus die einzelnen Probleme analysiert, die es für die zu konzeptionierende \ac{EUD}-Umgebung zu lösen gilt.

\subsection{Parallel contra Sequentiell -- Datenfluss contra Kontrollfluss}
Wie in den vorherigen Kapitel beschrieben, lässt sich die Kommunikation zwischen den einzelnen Knoten eines \ac{IoT}-System als \textit{aperiodisch} und \textit{parallel} beschreiben. Sensoren in einem solchen Verbund senden abhängig ihrer Abtastraten, asynchron Informationen als Datenpakete über ein \textit{Shared Medium} zu Signalwandlern (engl. "`\textit{Transducer}"'). Dieses Verhalten beschreibt einen Datenfluss von Erzeuger zu Konsument. \ac{EUD}-Werkzeuge wie beispielsweise SAM Studio oder LabVIEW nutzen hierbei Datenflussdiagramme, um den Benutzer ein organisieren und transformieren von Datenströme zu ermöglichen. Die Datenströme werden im \acp{cBlock}-Ökosystem unner von Aktoren konsumiert. Da Aktoren zu jeder Zeit nur einen Zustand (engl. "`\textit{State}"') annehmen können (bspw. kann ein Motor sich nicht parallel in zwei Richtungen drehen), ist die Verarbeitung der Eingangsignale \textbf{sequentiell}, anhand eines definierten Kontrollflusses. Hier liegt ein zentrales Problem: während die Orchestrierung zwischen den Nodes anhand von parallelen Datenflüssen modelliert wird, stellt sich die Signalverarbeitung bei den Aktuatoren als ein sequentieller Kontrollfluss dar. Eine \ac{EUD}-Lösung für cBlocks muss demnach beide Paradigmen effizient abbilden können: das Orchestrieren und Transformieren von parallelen Datenströmen sowie das Modellieren von sequentiellen Verhalten von Aktoren.

\subsection{Signalpriorisierung}
Bei der Signalpriorisierung handelt es sich um das Verhalten eines Daten-Konsuments (bspw. Aktor), wenn zwei, in Konflikt stehende Nachrichten eintreffen. Dieses Problem kann im folgenden Szenario verdeutlicht werden:
\begin{quote}
Regel A: "`Wenn es 32°C heiß ist, dann lass die LED rot aufleuchten."' \\
Regel B: "`Wenn es regnet, dann lass die LED blau aufleuchten."'
\end{quote}
Es wird schnell klar, dass beide Regeln in Konflikt zueinander stehen. Sollte es regnen und 32°C heiß sein, ist nicht klar, welche Farbe die LED hat. Falls das System keinen klar definiertes Verhalten bei kollidierenden Signalen besitzt, fällt es in einen nicht vorhersehbaren Zustand. \acp{EUD}-Werkzeuge besitzen daher unterschiedliche Herangehensweisen dieses Dilemma zu lösen: bei IFTTT beispielsweise gibt die Reihenfolge der Regeln an, welche Regel angewandt wird, bei SAM Space überschreibt das neueste Signal, das Letzte. Auch andere Systeme, wie das explizite Definieren von Priorisierung ist erdenklich \cite{MacLaurin2011kodu}. Es muss nur in Anbetracht gezogen werden, dass ohne eine solche Regelung das System intransparent für den Endnutzer wird und eine Fehlersuche erschwert.

\subsection{Visualisierung von Daten}
\begin{quote}
    "`\textit{Visualize Data, not Code. Dynamic behaviour, not static structure}"' \\ -- Bret Victor, \url{www.worrydream.com}
\end{quote}
In \ac{IoT} sind Daten, Dreh- und Wendepunkt für das Design von Systemen: Daten werden an den Sensoren erhoben, von Wandlern transformiert und von Aktoren konsumiert. Es macht daher Sinn, den Fokus der Visualisierung auf die Daten selbst zu setzen. Das Problem hierbei ist eine sinnvolle Darstellung für die Daten und deren Transformation zu finden. Während IFTTT diese Schwierigkeit durch einen vereinfachten Scope weitestgehend umgeht, benutzt SAM Labs animierte graphische Elemente um den Kontrollfluss darzustellen. Beide \ac{EUD}-Systeme stellen nur bedingt die Datenflüsse über eine zeitliche Dimension dar, dies erschwert die Fehlersuche da das Verhalten des Programmartefakts schwerer nachvollziehbar ist. Für professionelle Software-Engenieure ist ein solches Visualisieren der Daten unabdingbar. Das Verwenden von Debugging-Werkzeugen, welche diese Visualisierung ermöglichen, beherrschen den Programmier\-alltag. Für eine \ac{EUD} stellt sich daher das Problem, wie dieses Daten visualisiert werden können um das Verhalten, und den State des Programmartefakts auch für Laien erklärbar zu machen. 

\subsection{Funktionsumfang contra Komplexität}
Ein Beweggrund für die Entwicklung der cBlocks, ist das geringe Maß an Komplexität, welches ähnlichen Produkte wie SAM Labs oder Sonys MESH\footnote{\url{http://meshprj.com/en/}, besucht Juni 2018} zulässt. Der Grund hierfür ist, dass diese und viele weitere Produkte, ihren Fokus auf die Vermittlung von \textit{MINT}-Wissen legen. Diese Produkte werden an vorgefertigte Szenarien gebunden, welche von den Endnutzern nachgebildet werden sollen. Im Kontext des freien Prototypings, wird allerdings schnell klar, dass diese Werkzeuge auf Soft- und Hardwareebene an ihre Grenzen stoßen. Beim Design eines \ac{EUD}-Systems muss deren möglichen Umfang an abbildbarer Programmlogik mit der Darstellungskomplexität ausbalanciert werden. In SAM Labs wird die gewählte Balance bei der Steuerung von Aktoren verdeutlicht. Hierbei wird das Verhalten von Aktoren auf Eingangssignale nicht selbst gesteuert. Vielmehr werden vorgefertigte Steuerungsblöcke verwendet, welche für jeden Aktor speziell vorgefertigt sind. Im Falle eines LED-Aktor währen dies Funktionen wie "`Farbe rotieren"' oder "`Helligkeit ändern"'. Dies erleichtert zwar die Programmierung, schränkt den Endutzer aber ein, sobald er für seinen Anwendungsfall speziellere Verhalten benötigt. Das Problem ist also, das bestehende Produkte nicht mit den erlernten Fähigkeiten des Endnutzers wachsen, sondern lediglich ein Einstieg in die Programmierung der \ac{IoT}-Domäne darstellen. Diese Werkzeuge werden (bewusst) obsolet, sobald ein Maß von Programmkomplexität erreicht wird. Ein daraus resultierendes Problem ist, das Werkzeuge wie SAM Studio nur bedingt den tatsächlichen Programmablauf abstrahieren und somit für die Programmierung relevante Konzepte relevante Konzepte (bspw. \textit{State-Machines} oder \textit{Event-Loops}) nicht vermitteln.

\subsection{Open Source}
Das Problem von geschlossenen/proprietären Systemen ist nicht nur für flowws relevant sondern auch für cBlocks ähnliche Projekte, die es erlauben \ac{IoT}-Produkte zu entwickeln. Bausätze wie SAM-Labs oder Sonys MESH sind weder auf Software- noch Hardwareebene erweiterbar. Dies schränkt den möglichen Funktionsumfang signifikant ein und macht eine Erweiterung und Fortentwicklung der Plattform abhängig vom Hersteller. Währenddessen, wurde das cBlocks-Projekt auch darauf ausgelegt, dass Endnutzer die Möglichkeit besitzen, das Ökosystem um eigene Blöcke zu erweitern. Dies verlangt der \ac{EUD}-Umgebung und Hardware ab, flexibel und erweiterbar zu sein. Es lässt sich vermuten, dass die Einschränkungen von bestehenden Werkzeugen aufgrund von Geschäftsmodellen existieren. Das Problem, welches hieraus resultiert ist, dass sie als Prototyping-Werkzeuge nur eingeschränkt verwendbar sind, da sich der Endnutzer dem Funktionsumfang des Werkzeugs anpassen muss -- umgekehrt, wie es sein sollte. Dies ist in einem Kontext, in dem eine \ac{EUD}-Umgebung als Vermittlungswerkzeug für generelles \textit{MINT}-Lehrmaterial dient verständlich, nicht aber, wenn Designer Prototypen in spezialisierten Anwendungsdomänen bauen müssen.
